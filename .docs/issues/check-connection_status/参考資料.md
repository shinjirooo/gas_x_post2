## 最終更新日
2025/08/01
## 公式リンク
https://devcommunity.x.com/t/announcing-connection-status-field-in-the-user-object-in-the-x-api-v2/212588
## 使用できるプランとスコープ
要点だけまとめます。
### 使えるプラン（契約）

* **`connection_status` は「Userオブジェクト」で返る追加フィールド**です。**Users Lookup系のエンドポイント**（例：`GET /2/users/by/username/:username` や `GET /2/users/me`）で `user.fields=connection_status` を付ければ取得できます。仕様上は Users Lookup が使えるプランなら利用可能です。([docs.x.com][1], [docs.x.com][2])
* なお **Follows Lookup（`/2/users/:id/following` / `followers`）とは別物**で、Follows Lookup は **Basic/Pro で制限され Enterprise が必要**というアナウンス/案内が複数あります。`connection_status` を使う理由はここにあります。([docs.x.com][3], [devcommunity.x.com][4])

### 必要な認可方式とスコープ

* **認可方式:** \*\*OAuth 2.0（ユーザーコンテキスト）\*\*で呼び出してください。**App-only（アプリだけの Bearer）では `connection_status` は返らない**と案内されています。([devcommunity.x.com][5], [devcommunity.x.com][6])
* **スコープ:** Users Lookup のスコープに従い、**`users.read`**（＋多くのユーザー系で並記される **`tweet.read`**）を付ければ十分です。`connection_status` 取得に **`follows.read` は不要**です（それは Follows Lookup 用）。([docs.x.com][7])
* **任意（リフレッシュ用）:** トークン更新を楽にするなら **`offline.access`** を追加。([docs.x.com][7])

> 参考：`connection_status` は「**認可したユーザー**と**対象ユーザー**の関係」を返す、とデータ辞書に記載があります。([docs.x.com][2])

必要なら、この前提で **GAS（Apps Script）用の OAuth2（PKCE）設定と最小コード**を用意します。どのフロー（`/users/me` か `/users/by/username`）から使う予定か教えてください。

[1]: https://docs.x.com/x-api/users/user-lookup-me "Get my User - X"
[2]: https://docs.x.com/x-api/fundamentals/data-dictionary "X API v2 data dictionary - X"
[3]: https://docs.x.com/changelog?utm_source=chatgpt.com "Changelog - Welcome to the X Developer Platform"
[4]: https://devcommunity.x.com/t/twitter-followers-api-required-plan/222600?utm_source=chatgpt.com "Twitter Followers api required plan - X Developers"
[5]: https://devcommunity.x.com/t/retrieve-the-connection-status-field-with-app-only-authentication/214460?utm_source=chatgpt.com "Retrieve the Connection_status field with App Only authentication"
[6]: https://devcommunity.x.com/t/retrieve-connection-status-app-only-authentication/215953?utm_source=chatgpt.com "Retrieve connection_status (App-only authentication) - X Developers"
[7]: https://docs.x.com/resources/fundamentals/authentication/guides/v2-authentication-mapping "X API v2 authentication mapping - X"

## フォロー / 被フォロー関係の判定方法
以下の手順で\*\*GAS＋OAuth2（ユーザーコンテキスト）\*\*で判定できます。

---

## 判定の考え方

1. **エンドポイント**
   `GET /2/users/by/username/:username?user.fields=connection_status` を**ユーザーコンテキストのアクセストークン**で呼ぶと、レスポンスの `data.connection_status`（配列）に、**認可したユーザー↔対象ユーザー**の関係が入ります。少なくとも `following` / `followed_by` が分かります。([docs.x.com][1])

2. **必要条件**

* 認可方式は **OAuth 2.0 Authorization Code + PKCE（ユーザーコンテキスト）** か OAuth1.0a。**App-only（アプリのみのBearer）だと `connection_status` は返らない**ので注意。([docs.x.com][2], [devcommunity.x.com][3])

3. **判定ルール（代表）**

* `connection_status` に `following` が含まれる → **あなた → 相手 をフォロー**
* `connection_status` に `followed_by` が含まれる → **相手 → あなた をフォロー**
* 両方あれば **相互**、どちらも無ければ **フォロー関係なし**（あるいは非公開などの別状態）
  ※ 状態は他にも `follow_request_sent`（申請中）等が返ることがあります。([docs.x.com][1])

---

## GAS最小コード例（判定）

```javascript
// 事前に OAuth2 ライブラリ（apps-script-oauth2）を導入し、
// ユーザーコンテキストのトークンを取得できる状態にしておきます。
// スコープ例: users.read tweet.read offline.access

function getXService_() {
  return OAuth2.createService('x-pkce')
    .setAuthorizationBaseUrl('https://x.com/i/oauth2/authorize')
    .setTokenUrl('https://api.x.com/2/oauth2/token')
    .setClientId(PropertiesService.getScriptProperties().getProperty('X_CLIENT_ID'))
    .setCallbackFunction('authCallback')
    .setPropertyStore(PropertiesService.getUserProperties())
    .setScope('users.read tweet.read offline.access');
}

function authCallback(request) {
  const ok = getXService_().handleCallback(request);
  return HtmlService.createHtmlOutput(ok ? 'Authorized' : 'Denied');
}

function getRelationWith(username) {
  const service = getXService_();
  if (!service.hasAccess()) throw new Error('Authorize first');

  const url = `https://api.x.com/2/users/by/username/${encodeURIComponent(username)}?user.fields=connection_status`;
  const res = UrlFetchApp.fetch(url, {
    headers: { Authorization: 'Bearer ' + service.getAccessToken() },
    muteHttpExceptions: true,
  });
  const json = JSON.parse(res.getContentText());
  const st = json?.data?.connection_status || [];

  return {
    target: json?.data?.username || username,
    following: st.includes('following'),
    followed_by: st.includes('followed_by'),
    raw: st,
    relation:
      st.includes('following') && st.includes('followed_by') ? 'mutual' :
      st.includes('following') ? 'you_follow_them' :
      st.includes('followed_by') ? 'they_follow_you' :
      'none'
  };
}
```

---

## うまく出ないときのチェック

* **`user.fields=connection_status` を付けているか**。([docs.x.com][1])
* **トークンがユーザーコンテキストか**（App-onlyでは不可）。([docs.x.com][2], [devcommunity.x.com][3])
* 対象が**非公開アカウント／ブロック等**だと、`following`/`followed_by` 以外の状態や空になることがあります（そのまま `raw` を見て分岐）。

必要なら、上の雛形に**PKCEの code\_verifier 生成**や**エラーハンドリング**を足して仕上げます。環境（既に認可済みか、未認可か）を教えてもらえれば、そのまま動く形に整えます。

[1]: https://docs.x.com/x-api/users/get-user-by-username "Get User by username - X"
[2]: https://docs.x.com/x-api/users/lookup/introduction "Introduction - X"
[3]: https://devcommunity.x.com/t/retrieve-the-connection-status-field-with-app-only-authentication/214460?utm_source=chatgpt.com "Retrieve the Connection_status field with App Only authentication"
