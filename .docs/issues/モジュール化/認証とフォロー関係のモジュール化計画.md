## 目的
認証（OAuth2 PKCE + トークン更新 + API呼び出しラッパ）とフォロー関係チェック（ユーザー取得/関係判定）を、別プロジェクトへコピペで持ち込める単一ファイルモジュールとして分離する。Apps Script のグローバル名前空間衝突を避け、プロパティキーや公開関数名も衝突しないようにする。

## 前提・制約（Apps Script）
- import/export は使わず、各ファイルは同一グローバルに読み込まれる。
- 同名の関数/変数は後勝ちで上書きされる。
- `doGet` はプロジェクト内で唯一にする必要がある。

## 衝突回避の基本方針
- グローバル公開はトップレベルに `GX`（Gas X）のみを作る。
  - その下に `GX.Auth`（認証）と `GX.Follow`（フォロー関係）を配置。
- 実装は IIFE（即時関数）でクロージャに閉じ、内部定数・関数は非公開。
- スクリプトプロパティのキーはすべて `GX_AUTH_` プレフィックスで統一。
- グローバル関数で競合しやすい `doGet` はモジュール側では定義しない。
  - 利用側で薄い `doGet` を用意し、`GX.Auth.handleOAuthCallback(e)` に委譲。

## ファイル構成案（コピペ用 単一ファイル×2）
- `gx_auth.gs`（または `.js`）: 認証 + トークン更新 + API呼び出しラッパ
- `gx_follow.gs`（または `.js`）: ユーザー取得 + フォロー関係判定

## 公開API（安定インターフェース）
### GX.Auth
- `GX.Auth.getAuthorizationUrl(): string`
- `GX.Auth.hasAccess(): boolean`
- `GX.Auth.handleOAuthCallback(e: GoogleAppsScript.Events.DoGet): GoogleAppsScript.HTML.HtmlOutput`
- `GX.Auth.call(method: 'GET'|'POST'|'PUT'|'DELETE', url: string, headers?: object, payload?: any): any`
- `GX.Auth.setDebug(enabled: boolean): void`

内部で使用するスクリプトプロパティキー（例）
- `GX_AUTH_CLIENT_ID`
- `GX_AUTH_CLIENT_SECRET`
- `GX_AUTH_REDIRECT_URI`
- `GX_AUTH_ACCESS_TOKEN`
- `GX_AUTH_REFRESH_TOKEN`
- `GX_AUTH_VERIFIER`
- `GX_AUTH_CODE_CHALLENGE`

（任意）初期設定支援を行う場合は `GX.Auth.setupSheet.*` をサブ名前空間で公開（必要なプロジェクトでのみ利用）。

### GX.Follow
- `GX.Follow.getUserByUsername(username: string): any`  // `connection_status` を含む
- `GX.Follow.checkUserFollowsMe(username: string): { target, followed_by, following, raw, relation }`
- `GX.Follow.checkRelations(usernames: string[]): Record<string, Result>`

依存関係: `GX.Follow` は HTTP 呼び出しに `GX.Auth.call` を使用する。

## 実装イメージ（抜粋）
```javascript
// グローバル公開は GX のみ
this.GX = this.GX || {};

// 認証モジュール
this.GX.Auth = (function () {
  var DEBUG = false;
  var AUTHORIZE_URL = 'https://twitter.com/i/oauth2/authorize';
  var TOKEN_URL = 'https://api.twitter.com/2/oauth2/token';
  var API_BASE_URL = 'https://api.twitter.com/2';
  var SCOPE = 'users.read%20tweet.read%20offline.access';
  var STATE = 'gx_default_state';

  function getProp(key) { return PropertiesService.getScriptProperties().getProperty(key); }
  function setProp(key, value) { PropertiesService.getScriptProperties().setProperty(key, value); }

  function getPKCE() { /* code.js の getPKCE を内部関数化（キーは GX_AUTH_* に変更）*/ }
  function getBasicAuthorization() { /* clientId/secret を GX_AUTH_* から読み出し */ }
  function refreshToken() { /* 401時の更新 */ }
  function call(method, url, headers, payload) { /* アクセストークン付与と 401 ハンドリング */ }

  function getAuthorizationUrl() { /* 認可URLを構築 */ }
  function hasAccess() { return !!getProp('GX_AUTH_ACCESS_TOKEN'); }
  function handleOAuthCallback(e) { /* code からトークン保存、HTML を返す */ }

  return {
    call: call,
    getAuthorizationUrl: getAuthorizationUrl,
    hasAccess: hasAccess,
    handleOAuthCallback: handleOAuthCallback,
    setDebug: function (enabled) { DEBUG = !!enabled; }
  };
})();

// フォロー関係モジュール
this.GX.Follow = (function () {
  var API_BASE_URL = 'https://api.twitter.com/2';

  function normalize(name) { return String(name || '').trim().replace(/^@/, ''); }

  function getUserByUsername(username) {
    var u = normalize(username);
    var url = API_BASE_URL + '/users/by/username/' + encodeURIComponent(u) + '?user.fields=connection_status,name,username';
    return GX.Auth.call('GET', url, {}, undefined);
  }

  function checkUserFollowsMe(username) {
    var user = getUserByUsername(username);
    var status = user && user.data && user.data.connection_status ? user.data.connection_status : [];
    var followedBy = Array.isArray(status) && status.indexOf('followed_by') !== -1;
    var following = Array.isArray(status) && status.indexOf('following') !== -1;
    return {
      target: (user && user.data && user.data.username) ? user.data.username : normalize(username),
      followed_by: !!followedBy,
      following: !!following,
      raw: status,
      relation: (followedBy && following) ? 'mutual' : (followedBy ? 'they_follow_you' : (following ? 'you_follow_them' : 'none'))
    };
  }

  function checkRelations(usernames) {
    var list = Array.isArray(usernames) ? usernames : [];
    var res = {};
    for (var i = 0; i < list.length; i++) {
      var uname = normalize(list[i]);
      res[uname] = checkUserFollowsMe(uname);
    }
    return res;
  }

  return { getUserByUsername: getUserByUsername, checkUserFollowsMe: checkUserFollowsMe, checkRelations: checkRelations };
})();
```

※ 上記は構造イメージ。実コードは既存 `src/code.js` の該当処理を移植し、プロパティキーと公開名のみ変更する。

## 既存コードからの対応表
- 定数/URL/スコープ類（`AUTHORIZE_URL`, `TOKEN_URL`, `API_BASE_URL`, `SCOPE`, `STATE`, `DEBUG`）
  - → `GX.Auth` のクロージャ内部定数へ（`DEBUG` は `setDebug` で切替）
- `getPKCE` / `getBasicAuthorization` / `getToken` / `getRefreshedToken` / `hasAccess`
  - → `GX.Auth` 内部関数 + 公開API（`hasAccess` を公開）
- `xApiCall`
  - → `GX.Auth.call`（401→refresh→再実行の流れを踏襲）
- `doGet`
  - → 非公開化。利用側が以下を定義:
    ```javascript
    function doGet(e) { return GX.Auth.handleOAuthCallback(e); }
    ```
- `xGetUserByUsername` / `checkUserFollowsMe` / `checkFollowRelationsForUsernames`
  - → `GX.Follow.getUserByUsername` / `GX.Follow.checkUserFollowsMe` / `GX.Follow.checkRelations`
- デモ/サンプル関数（`debugCheckFollow`, `checkFollowRelationsFor0125ss25AndMmrArs`, `xGetMyRecentTweets` など）
  - → 任意の別ファイルにサンプルとして分離（本モジュール外）。

## プロパティキー移行
現行キー → 新キー
- `CLIENT_ID` → `GX_AUTH_CLIENT_ID`
- `CLIENT_SECRET` → `GX_AUTH_CLIENT_SECRET`
- `REDIRECT_URI` → `GX_AUTH_REDIRECT_URI`
- `ACCESS_TOKEN` → `GX_AUTH_ACCESS_TOKEN`
- `REFRESH_TOKEN` → `GX_AUTH_REFRESH_TOKEN`
- `VERIFIER` → `GX_AUTH_VERIFIER`
- `CODE_CHALLENGE` → `GX_AUTH_CODE_CHALLENGE`

（一時移行スニペット）
```javascript
function migratePropsToGX() {
  var p = PropertiesService.getScriptProperties();
  var map = {
    CLIENT_ID: 'GX_AUTH_CLIENT_ID',
    CLIENT_SECRET: 'GX_AUTH_CLIENT_SECRET',
    REDIRECT_URI: 'GX_AUTH_REDIRECT_URI',
    ACCESS_TOKEN: 'GX_AUTH_ACCESS_TOKEN',
    REFRESH_TOKEN: 'GX_AUTH_REFRESH_TOKEN',
    VERIFIER: 'GX_AUTH_VERIFIER',
    CODE_CHALLENGE: 'GX_AUTH_CODE_CHALLENGE'
  };
  Object.keys(map).forEach(function (k) {
    var v = p.getProperty(k);
    if (v) p.setProperty(map[k], v);
  });
}
```

## 導入手順（別プロジェクト）
1) `gx_auth.gs` と `gx_follow.gs` をコピペで追加
2) `doGet` を以下の 1 行に置換/追加
```javascript
function doGet(e) { return GX.Auth.handleOAuthCallback(e); }
```
3) スクリプトプロパティに下記を設定
   - `GX_AUTH_CLIENT_ID`, `GX_AUTH_CLIENT_SECRET`, `GX_AUTH_REDIRECT_URI`
4) ウェブアプリとしてデプロイ（URL を X Developer Portal の Callback に設定）
5) 認証前フロー
   - `GX.Auth.getAuthorizationUrl()` をログ出力/画面などで提示
6) 認証後は `GX.Auth.hasAccess()` を確認し、API 呼び出しは `GX.Auth.call(...)` を経由
7) フォロー関係は `GX.Follow.checkUserFollowsMe('@username')` などを使用

## サンプル利用コード（別プロジェクト）
```javascript
function example() {
  if (!GX.Auth.hasAccess()) {
    Logger.log('Authorize here:');
    Logger.log(GX.Auth.getAuthorizationUrl());
    return;
  }
  var result = GX.Follow.checkUserFollowsMe('0125ss25');
  Logger.log(JSON.stringify(result, null, 2));
}
```

## テスト観点（最低限）
- 未認証時: `getAuthorizationUrl` が正しいパラメータで生成される
- `doGet` デリゲーションでトークン保存後、`hasAccess` が true になる
- 有効トークンで `GX.Auth.call` が 200 台のレスポンスを返す
- 401 で自動リフレッシュ→再試行が成功する
- `GX.Follow.checkUserFollowsMe` が `relation` を正しく判定

## 将来拡張
- `GX.Auth` にレートリミット/リトライポリシーを追加
- `GX.Follow` にバルクAPI/キュー処理を追加
- Apps Script Library 化（ID で配布）も選択肢（ただし本計画はコピペ配布を主眼）


